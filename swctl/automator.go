// Copyright (C) 2025 - Damien Dejean <dam.dejean@gmail.com>

package main

import (
	"context"
	"fmt"
	"log"
	"os"
	"os/exec"
	"time"

	xmodem "github.com/azurity/xmodem-go"
	"github.com/machinebox/progress"
	"github.com/tarm/serial"
)

const (
	confTimeout = 30 * time.Second
)

type automator struct {
	// File to boot.
	file string
	// File size.
	fileSize int64
	// Baudset file to load.
	baudset string
	// Baudset file size.
	baudsetSize int64

	// Serial port instance.
	port *serial.Port
	// Scanner bound to the serial port.
	scr *scanner
	// State machine processing the serial console content.
	sm *csm
}

func newAutomator(tty *serial.Port, file string, baudset string) *automator {
	return &automator{
		port:    tty,
		file:    file,
		baudset: baudset,
	}
}

func (a *automator) open() error {
	fstats, err := os.Stat(a.file)
	if err != nil {
		return err
	}
	a.fileSize = fstats.Size()

	fstats, err = os.Stat(a.baudset)
	if err != nil {
		return err
	}
	a.baudsetSize = fstats.Size()

	a.scr = newScanner(a.port)
	a.sm = newConsoleStateMachine(a)
	return nil
}

func (a *automator) run() (bool, error) {
	tok, lit := a.scr.scan()
	done, err := a.sm.run(tok, lit)
	if err != nil {
		return done, err
	}
	return done, nil
}

func (a *automator) onHitAnyKey() error {
	// Console waiting for a user input to enter the debug mode.
	if err := a.write("a"); err != nil {
		return err
	}
	return nil
}

func (a *automator) onWaitForBaudset() error {
	// Since the baudset binary is very small and we don't control cache flush,
	// upload it to an uncached area to avoid weird behavior issue.
	return a.atUp(0xa1700000, int(a.baudsetSize))
}

func (a *automator) onWaitForBaudsetUpload() error {
	return a.upload(a.baudset, a.baudsetSize)
}

func (a *automator) onBaudsetReady() error {
	return a.atGo(0xa17000c0)
}

func (a *automator) onBaudsetDone() error {
	stty := exec.Command("stty", "-F", "/dev/ttyUSB0", "921600")
	if err := stty.Run(); err != nil {
		return err
	}
	// Send 3 AT commands to be sure to recover the prompt from the garbae
	// generated by the baudrate change.
	for i := 0; i < 3; i++ {
		if err := a.write("AT\r\n"); err != nil {
			return err
		}
		time.Sleep(500 * time.Millisecond)
	}
	return nil
}

func (a *automator) onWaitForFirmware() error {
	return a.atUp(0x81800000, int(a.fileSize))
}

func (a *automator) onWaitForFirmwareUpload() error {
	return a.upload(a.file, a.fileSize)
}

func (a *automator) onReadyToBoot() error {
	if err := a.atBa(5); err != nil {
		return err
	}

	stty := exec.Command("stty", "-F", "/dev/ttyUSB0", "115200")
	if err := stty.Run(); err != nil {
		return err
	}

	// Send 3 AT commands to be sure to recover the prompt from the garbae
	// generated by the baudrate change.
	for i := 0; i < 3; i++ {
		if err := a.write("AT\r\n"); err != nil {
			return err
		}
		time.Sleep(500 * time.Millisecond)
	}

	return a.atGo(0x81800000)
}

func (a *automator) atUp(addr uint, size int) error {
	return a.write(fmt.Sprintf("ATUP %x,%x\r\n", addr, size))
}

func (a *automator) atGo(addr uint) error {
	return a.write(fmt.Sprintf("ATGO %x\r\n", addr))
}

func (a *automator) atBa(level uint) error {
	if level < 1 || level > 5 {
		return fmt.Errorf("invalid ATBA level %v", level)
	}
	return a.write(fmt.Sprintf("ATBA %x\r\n", level))
}

func (a *automator) upload(file string, size int64) error {
	f, err := os.OpenFile(file, 0, os.FileMode(os.O_RDONLY))
	if err != nil {
		return err
	}
	defer f.Close()

	r := progress.NewReader(f)
	conf := xmodem.XModemConfig(xmodem.ModemFnCRC | xmodem.ModemFn1k)
	m, _, _ := xmodem.NewModem(conf, a.port, a.port)
	ctx, cancel := context.WithCancel(context.Background())

	go func(ctx context.Context) {
		progressChan := progress.NewTicker(ctx, r, size, 1*time.Second)
		for p := range progressChan {
			fmt.Fprintf(log.Writer(), "\r%.1f%c (%v remaining)   ", p.Percent(), '%', p.Remaining().Round(time.Second))
		}
		log.Println("\rUpload completed")
	}(ctx)

	if err := m.SendBytes(r); err != nil {
		return err
	}
	cancel()

	return nil

}

func (a *automator) write(cmd string) error {
	if _, err := a.port.Write([]byte(cmd)); err != nil {
		return fmt.Errorf("failed to write: %v", err)
	}
	return nil
}
